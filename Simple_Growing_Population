import numpy as np
import matplotlib.pyplot as plt
import time

MAX_POPULATION = 1000
N_SIMULATIONS = 10

def general_logistic_growth(population, growth_rate, carrying_capacity, alpha=1, beta=0, gamma=0):
    return growth_rate * (population**alpha) * (1 - (population / carrying_capacity)**beta)**gamma

def exponential_growth(population, growth_rate, carrying_capacity, alpha=1, beta=0, gamma=0):
    return general_logistic_growth(population, growth_rate, np.inf, 1, 0, 0)

def logistic_growth(population, growth_rate, carrying_capacity,alpha=1, beta=0, gamma=0):
    return general_logistic_growth(population, growth_rate, carrying_capacity, 1, 1, 1)

def richards_growth(population, growth_rate, carrying_capacity, alpha, beta, gamma):
    return general_logistic_growth(population, growth_rate, carrying_capacity, 1, beta, 1)

def blumberg_growth(population, growth_rate, carrying_capacity, alpha, beta, gamma):
    return general_logistic_growth(population, growth_rate, carrying_capacity, alpha, beta, 1)

def gompertz_growth(population, growth_rate, carrying_capacity, alpha, beta, gamma):
    return growth_rate * population *np.log(carrying_capacity/population)

class Cell:

    def __init__(self, growth_rate, name):
        self.growth_rate = growth_rate
        self.name = name
        self.generation = 0


    def reproduce(self, std_growth_rate=5e-4):
        new_growth_rate = self.growth_rate + np.random.normal(0, std_growth_rate)
        new_cell =  Cell(new_growth_rate, self.name)
        new_cell.generation = self.generation + 1
        return new_cell





    
def gillespie_algorithm(initial_cells,
                        total_time,
                        growth_rate_model,
                        carrying_capacity,
                        alpha=1,
                        beta=0,
                        gamma=0,
                        std_growth_rate = 5e-4,
                        death_rate=0.5):

    populations = np.array([len(initial_cells)])
    n_events, n_death, n_born = 0, 0, 0
    time = 0
    timesteps = [time]


    # Initializing current state variables
    cell_batch = initial_cells
    current_rates = np.array([cell.growth_rate for cell in cell_batch])
    sum_rates = np.sum(current_rates)
    mean_rate = sum_rates / len(cell_batch)

    rate_evolution = [mean_rate]

    total_growth_rate = growth_rate_model(len(cell_batch), mean_rate, carrying_capacity,alpha, beta, gamma)
    effective_growth_rate_evolution = [total_growth_rate/len(cell_batch)-death_rate]

    total_death_rate = death_rate * len(cell_batch)

    generations = [0] * len(cell_batch)
    mean_generation = [0]

    while time < total_time:

        # Checking for extinction
        if len(cell_batch) == 0:
            print("extinction")
            break

        # Checking if the population is too large
        if len(cell_batch) > 13000:
            # Printing statistics and histograms and then breaking the loop
            print(f"N_death : {n_death}, N_born : {n_born}, N_events : {n_events}\n")

        # Generating the next time step
        dt = np.random.exponential(1 / (total_growth_rate + total_death_rate))
        time += dt

        # Calculating probabilities for each event
        death_birth_probability = [total_growth_rate /( total_growth_rate + total_death_rate), total_death_rate / (total_growth_rate + total_death_rate)]

        # Choosing the event to occur based on the probabilities
        event = np.random.choice(2, p=death_birth_probability)
        n_events += 1


        # Handling event: death
        if event == 1:
            dead_cell_index = np.random.choice(len(cell_batch))
            dead_cell = cell_batch.pop(dead_cell_index)

            # Checking for extinction
            if len(cell_batch) == 0:
                print("extinction")
                break

            populations = np.append(populations, len(cell_batch))
            current_rates = np.delete(current_rates, dead_cell_index )
            generations.pop(dead_cell_index)

            sum_rates -= dead_cell.growth_rate
            mean_rate = sum_rates / len(cell_batch)
            total_growth_rate = growth_rate_model(len(cell_batch), mean_rate, carrying_capacity,alpha, beta, gamma)
            total_death_rate -= death_rate


            n_death += 1
        else:
            # Handling event: birth
            probabilities = current_rates / sum_rates
            new_cell_index = np.random.choice(len(current_rates), p=probabilities)
            new_cell = cell_batch[new_cell_index].reproduce(std_growth_rate)
            cell_batch.append(new_cell)
            n_born += 1
            populations = np.append(populations, len(cell_batch))
            total_death_rate += death_rate
            sum_rates += new_cell.growth_rate
            mean_rate = sum_rates / len(cell_batch)
            current_rates = np.append(current_rates, new_cell.growth_rate)
            total_growth_rate = growth_rate_model(len(cell_batch), mean_rate, carrying_capacity,alpha, beta, gamma)
            generations.append(new_cell.generation)

        # Appending time and data for plotting
        timesteps.append(time)

        rate_evolution.append(mean_rate)
        effective_growth_rate_evolution.append(total_growth_rate / len(cell_batch) - death_rate)
        mean_generation.append(np.mean(generations))


    print(f"N_death : {n_death}, N_born : {n_born}, N_events : {n_events}\n")
    return (timesteps,
            populations,
            np.array(rate_evolution),
            np.array(effective_growth_rate_evolution),
            np.array(mean_generation)
    )



"""
start = time.time()
(timesteps, populations, 
 rate_evolution,effective_growth_rate_evolution, 
 mean_generation) = gillespie_algorithm(initial_cells, 
                                        total_time, 
                                        logistic_growth,
                                        std_growth_rate=std_growth_rate,
                                        carrying_capacity=MAX_POPULATION, 
                                        death_rate=death_rate)
stop = time.time()
print(f"Execution time: {stop - start}")

plt.figure()
plt.plot(timesteps, populations)
plt.title("Population growth")
plt.xlabel("Time")
plt.ylabel("Population")

plt.figure()
plt.plot(timesteps, rate_evolution)
plt.title("Growth rate evolution")
plt.xlabel("Time")
plt.ylabel("Growth rate")

plt.figure()
plt.plot(timesteps, effective_growth_rate_evolution)
plt.plot(timesteps, [0]*len(timesteps), linestyle="--", color="red")
plt.title("Effective growth rate evolution")
plt.xlabel("Time")
plt.ylabel("Effective growth rate")

plt.figure()
plt.plot(timesteps, mean_generation)
plt.title("Mean generation evolution")
plt.xlabel("Time")
plt.ylabel("Mean generation")


plt.show()

def run_gillespie_simulations(N_simulations, initial_population, growth_rate_model, total_time, carrying_capacity, death_rate, std_growth_rate):
    initial_cells = [[Cell(0.11, "cell_1") for _ in range(initial_population)] for _ in range(N_simulations)]
    simulation_results = [
        gillespie_algorithm(initial_cells[i], total_time, growth_rate_model, carrying_capacity, death_rate=death_rate, std_growth_rate=std_growth_rate)
        for i in range(N_simulations)
    ]
    return simulation_results


# Exécution des simulations
start = time.time()
simulation_results = run_gillespie_simulations(N_SIMULATIONS, initial_population, logistic_growth, total_time, MAX_POPULATION, death_rate, std_growth_rate)
stop = time.time()

print(f"Execution time gillespies: {stop - start}")


start = time.time()
# Récupérer les timesteps de chaque simulation
all_timesteps = [result[0] for result in simulation_results]

# Fusionner les listes de timesteps
merged_timesteps = np.concatenate(all_timesteps)

# Trier les timesteps fusionnés
sorted_merged_timesteps = np.sort(merged_timesteps)

# Supprimer les doublons (si nécessaire)
merged_timesteps = np.unique(sorted_merged_timesteps)

populations_list = [result[1] for result in simulation_results]
rate_evolution_list = [result[2] for result in simulation_results]
effective_growth_rate_evolution_list = [result[3] for result in simulation_results]
mean_generation_list = [result[4] for result in simulation_results]

# Créer un tableau pour stocker les résultats étendus
extended_results = np.empty((len(merged_timesteps), N_SIMULATIONS, 4))

# Pour chaque simulation, récupérer les indices correspondant aux timesteps fusionnés
for i in range(N_SIMULATIONS):
    indices = np.searchsorted(all_timesteps[i], merged_timesteps)
    indices[indices == 0] = 1  # Remplacer les indices 0 par 1 pour éviter une erreur lors de l'indexation
    indices = indices - 1  # Décrémenter les indices pour obtenir les valeurs correspondantes
    # Pour chaque résultat, insérer les valeurs correspondantes aux indices trouvés
    extended_results[:, i, 0] = populations_list[i][indices]
    extended_results[:, i, 1] = rate_evolution_list[i][indices ]
    extended_results[:, i, 2] = effective_growth_rate_evolution_list[i][indices ]
    extended_results[:, i, 3] = mean_generation_list[i][indices ]


# Calculer la moyenne des valeurs pour chaque timestep
averaged_results = np.mean(extended_results, axis=1)

# Extraire les valeurs pour le tracé
timesteps = merged_timesteps
average_populations = averaged_results[:, 0]
average_rate_evolution = averaged_results[:, 1]
average_effective_growth_rate_evolution = averaged_results[:, 2]
average_mean_generation = averaged_results[:, 3]
stop = time.time()

print(f"Execution time data treatment: {stop - start}")
print(f"N_timesteps: {len(timesteps)}")
# Tracer les courbes

plt.figure()
plt.plot(timesteps, average_populations)
plt.title('Average Population Over Time')
plt.xlabel('Time')
plt.ylabel('Average Population')

plt.figure()
plt.plot(timesteps, average_rate_evolution)
plt.title('Average Rate Evolution Over Time')
plt.xlabel('Time')
plt.ylabel('Average Rate Evolution')

plt.figure()
plt.plot(timesteps, average_effective_growth_rate_evolution)
plt.title('Average Effective Growth Rate Evolution Over Time')
plt.xlabel('Time')
plt.ylabel('Average Effective Growth Rate Evolution')

plt.figure()
plt.plot(timesteps, average_mean_generation)
plt.title('Average Mean Generation Over Time')
plt.xlabel('Time')
plt.ylabel('Average Mean Generation')

plt.show()



"""


np.random.seed(0)
initial_population = 50
initial_cells = [Cell(0.11, "cell_1") for _ in range(initial_population)]
total_time = 500
death_rate = 0.03
std_growth_rate = 1e-3

def broadcast_gillespie_algorithm(initial_cells,
                        total_time,
                        growth_rate_model,
                        carrying_capacity,
                        alpha=1,
                        beta=0,
                        gamma=0,
                        std_growth_rate=5e-4,
                        death_rate=0.5,
                        N_simulations=10):

    initial_population = len(initial_cells)
    populations =[[ initial_population for _ in range(N_simulations)]]
    rate_evolution = [np.array([np.mean([cell.growth_rate for cell in initial_cells]) for _ in range(N_simulations)])]
    mean_generation = [[0] * N_simulations]

    cell_batch = []
    generations = []
    for i in range(N_simulations):
        cell_batch.append(initial_cells.copy())
        generations.append([0] * initial_population)
    current_rates = [[cell.growth_rate for cell in sim] for sim in cell_batch]
    sum_rates = np.sum(current_rates, axis=1)
    mean_rates = sum_rates / initial_population
    


    total_growth_rates = growth_rate_model(initial_population, mean_rates, carrying_capacity, alpha, beta, gamma)
    total_death_rates = [death_rate * initial_population ] * N_simulations
    effective_growth_rate_evolution = [list(total_growth_rates / initial_population - death_rate)]

    current_time = 0
    timesteps = np.zeros(1)

    next_time_steps = [np.random.exponential(1 / (total_growth_rates[i] + total_death_rates[i])) for i in range(N_simulations)]
    N_deaths = [0] * N_simulations
    N_borns = [0] * N_simulations

    while current_time < total_time:
        sim_index = np.argmin(next_time_steps)
        current_time = next_time_steps[sim_index]

        death_birth_events = np.random.rand() < (total_death_rates[sim_index] / (total_growth_rates[sim_index] + total_death_rates[sim_index]))

        # Handling event: death
        if death_birth_events.any():
            dead_cell_index = np.random.choice(len(cell_batch[sim_index]))
            dead_cell =  cell_batch[sim_index].pop(dead_cell_index)
           

            # Checking for extinction
            if len(cell_batch[sim_index]) == 0:
                print("extinction")
                break
            current_rates[sim_index].pop(dead_cell_index)
            generations[sim_index].pop(dead_cell_index)
            total_death_rates[sim_index] -= death_rate
            sum_rates[sim_index] -= dead_cell.growth_rate
            mean_rates[sim_index] = sum_rates[sim_index] / len(cell_batch[sim_index])
            total_growth_rates[sim_index] = growth_rate_model(len(cell_batch[sim_index]), mean_rates[sim_index], carrying_capacity, alpha, beta, gamma)

            N_deaths[sim_index] += 1
        else:
            # Handling event: birth
            probabilities = current_rates[sim_index] / np.sum(current_rates[sim_index])
            new_cell_index = np.random.choice(len(cell_batch[sim_index]), p=probabilities)
            new_cell = cell_batch[sim_index][new_cell_index].reproduce(std_growth_rate)
            cell_batch[sim_index].append(new_cell)
            total_death_rates[sim_index] += death_rate
            sum_rates[sim_index] += new_cell.growth_rate
            mean_rates[sim_index] = sum_rates[sim_index] / len(cell_batch[sim_index])
            current_rates[sim_index].append(new_cell.growth_rate)
            total_growth_rates[sim_index] = growth_rate_model(len(cell_batch[sim_index]), mean_rates[sim_index], carrying_capacity,alpha, beta, gamma)
            generations[sim_index].append(new_cell.generation)
            N_borns[sim_index] += 1

        # Appending time and data for plotting
        timesteps = np.append(timesteps, current_time)
        next_time_steps[sim_index] = current_time + np.random.exponential(1 / (total_growth_rates[sim_index] + total_death_rates[sim_index]))

        rate_evolution.append(mean_rates.copy())
        effective_growth_rate_evolution.append( [total_growth_rates[i] / len(cell_batch[i]) - death_rate for i in range(N_simulations)])
        mean_generation.append(np.array([np.mean(generations[i]) for i in range(N_simulations)]))
        populations.append([len(cell_batch[i]) for i in range(N_simulations)])

    print("Simulation completed.")

    return timesteps, populations, rate_evolution, effective_growth_rate_evolution, mean_generation


start = time.time()
(timesteps, populations, rate_evolution, effective_growth_rate_evolution, mean_generation) = broadcast_gillespie_algorithm(initial_cells, total_time, logistic_growth, MAX_POPULATION, death_rate=death_rate, N_simulations=N_SIMULATIONS, std_growth_rate=std_growth_rate)
stop = time.time()
print(f"Execution time: {stop - start}")






# Extraire les valeurs pour le tracé
start = time.time()
populations = np.array(populations)
average_populations = np.mean(populations, axis=1)
average_rate_evolution = np.mean(rate_evolution, axis=1)
average_effective_growth_rate_evolution =   np.mean(effective_growth_rate_evolution, axis=1)
average_mean_generation = np.mean(mean_generation, axis=1)
stop = time.time()

print(f"Execution time data treatment: {stop - start}")
print(f"N_timesteps: {len(timesteps)}")
# Tracer les courbes

plt.figure()
plt.plot(timesteps, average_populations)
plt.title('Average Population Over Time')
plt.xlabel('Time')
plt.ylabel('Average Population')

plt.figure()
plt.plot(timesteps, average_rate_evolution)
plt.title('Average Rate Evolution Over Time')
plt.xlabel('Time')
plt.ylabel('Average Rate Evolution')

plt.figure()
plt.plot(timesteps, average_effective_growth_rate_evolution)
plt.title('Average Effective Growth Rate Evolution Over Time')
plt.xlabel('Time')
plt.ylabel('Average Effective Growth Rate Evolution')

plt.figure()
plt.plot(timesteps, average_mean_generation)
plt.title('Average Mean Generation Over Time')
plt.xlabel('Time')
plt.ylabel('Average Mean Generation')

plt.show()